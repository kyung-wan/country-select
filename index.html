<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>국기 퍼즐 회원가입 (Real Shapes)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Noto Sans KR', sans-serif;
            user-select: none;
        }

        #instruction {
            position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%);
            color: white; text-align: center; z-index: 1000; pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* --- 퍼즐 조각 스타일 업데이트 --- */
        .puzzle-piece {
            position: absolute;
            /* 원래 격자 크기(60x40)보다 조각을 더 크게 만듭니다.
               튀어나온 요철(Tab)을 표현하기 위한 여백이 필요하기 때문입니다.
            */
            width: 80px;
            height: 60px;
            
            /* 전체 국기 크기도 비율에 맞춰 조정 */
            background-size: 180px 120px; 
            
            cursor: grab;
            /* clip-path를 사용하면 기본 box-shadow가 잘리므로 filter drop-shadow 사용 */
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.5));
            transition: transform 0.1s;
            
            /* flex 설정은 텍스트 표시용 (이미지 사용시 제거 가능) */
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255,255,255,0.8);
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        .puzzle-piece:active {
            cursor: grabbing;
            transform: scale(1.05); /* 클릭 시 약간 커짐 */
            z-index: 999 !important;
        }

        .snapped {
            pointer-events: none;
            filter: none; /* 스냅되면 그림자 제거 */
            z-index: 1;
        }

        /* --- SVG Clip-Path 연결 --- */
        /* 각 위치별(행-열)로 미리 정의된 SVG 경로를 clip-path로 지정합니다.
           이 경로들이 실제 퍼즐 모양을 만듭니다.
        */
        .pos-0-0 { clip-path: url(#clip-0-0); }
        .pos-0-1 { clip-path: url(#clip-0-1); }
        .pos-0-2 { clip-path: url(#clip-0-2); }
        .pos-1-0 { clip-path: url(#clip-1-0); }
        .pos-1-1 { clip-path: url(#clip-1-1); }
        .pos-1-2 { clip-path: url(#clip-1-2); }
        .pos-2-0 { clip-path: url(#clip-2-0); }
        .pos-2-1 { clip-path: url(#clip-2-1); }
        .pos-2-2 { clip-path: url(#clip-2-2); }


        /* 결과 모달 (이전과 동일) */
        #modal {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 2000;
            justify-content: center; align-items: center; flex-direction: column; color: white;
        }
        button {
            padding: 10px 20px; margin-top: 20px; font-size: 16px; cursor: pointer;
            background: #4CAF50; color: white; border: none; border-radius: 5px;
        }
    </style>
</head>
<body>

    <svg width="0" height="0" style="position:absolute;">
        <defs>
            <clipPath id="clip-0-0" clipPathUnits="objectBoundingBox"><path d="M0,0 H1 V0.35 C1,0.35 0.9,0.37 0.9,0.45 C0.9,0.53 1,0.55 1,0.55 V1 H0.65 C0.65,1 0.63,0.9 0.55,0.9 C0.47,0.9 0.45,1 0.45,1 H0 V0 Z"></path></clipPath>
            <clipPath id="clip-0-1" clipPathUnits="objectBoundingBox"><path d="M0,0 H1 V0.35 C1,0.35 0.9,0.37 0.9,0.45 C0.9,0.53 1,0.55 1,0.55 V1 H0.65 C0.65,1 0.63,0.9 0.55,0.9 C0.47,0.9 0.45,1 0.45,1 H0 V0.55 C0,0.55 0.1,0.53 0.1,0.45 C0.1,0.37 0,0.35 0,0.35 V0 Z"></path></clipPath>
            <clipPath id="clip-0-2" clipPathUnits="objectBoundingBox"><path d="M0,0 H1 V1 H0.65 C0.65,1 0.63,0.9 0.55,0.9 C0.47,0.9 0.45,1 0.45,1 H0 V0.55 C0,0.55 0.1,0.53 0.1,0.45 C0.1,0.37 0,0.35 0,0.35 V0 Z"></path></clipPath>
            <clipPath id="clip-1-0" clipPathUnits="objectBoundingBox"><path d="M0,0 H0.45 C0.45,0 0.47,0.1 0.55,0.1 C0.63,0.1 0.65,0 0.65,0 H1 V0.35 C1,0.35 0.9,0.37 0.9,0.45 C0.9,0.53 1,0.55 1,0.55 V1 H0.65 C0.65,1 0.63,0.9 0.55,0.9 C0.47,0.9 0.45,1 0.45,1 H0 V0 Z"></path></clipPath>
            <clipPath id="clip-1-1" clipPathUnits="objectBoundingBox"><path d="M0,0 H0.45 C0.45,0 0.47,0.1 0.55,0.1 C0.63,0.1 0.65,0 0.65,0 H1 V0.35 C1,0.35 0.9,0.37 0.9,0.45 C0.9,0.53 1,0.55 1,0.55 V1 H0.65 C0.65,1 0.63,0.9 0.55,0.9 C0.47,0.9 0.45,1 0.45,1 H0 V0.55 C0,0.55 0.1,0.53 0.1,0.45 C0.1,0.37 0,0.35 0,0.35 V0 Z"></path></clipPath>
            <clipPath id="clip-1-2" clipPathUnits="objectBoundingBox"><path d="M0,0 H0.45 C0.45,0 0.47,0.1 0.55,0.1 C0.63,0.1 0.65,0 0.65,0 H1 V1 H0.65 C0.65,1 0.63,0.9 0.55,0.9 C0.47,0.9 0.45,1 0.45,1 H0 V0.55 C0,0.55 0.1,0.53 0.1,0.45 C0.1,0.37 0,0.35 0,0.35 V0 Z"></path></clipPath>
            <clipPath id="clip-2-0" clipPathUnits="objectBoundingBox"><path d="M0,0 H0.45 C0.45,0 0.47,0.1 0.55,0.1 C0.63,0.1 0.65,0 0.65,0 H1 V0.35 C1,0.35 0.9,0.37 0.9,0.45 C0.9,0.53 1,0.55 1,0.55 V1 H0 V0 Z"></path></clipPath>
            <clipPath id="clip-2-1" clipPathUnits="objectBoundingBox"><path d="M0,0 H0.45 C0.45,0 0.47,0.1 0.55,0.1 C0.63,0.1 0.65,0 0.65,0 H1 V0.35 C1,0.35 0.9,0.37 0.9,0.45 C0.9,0.53 1,0.55 1,0.55 V1 H0 V0.55 C0,0.55 0.1,0.53 0.1,0.45 C0.1,0.37 0,0.35 0,0.35 V0 Z"></path></clipPath>
            <clipPath id="clip-2-2" clipPathUnits="objectBoundingBox"><path d="M0,0 H0.45 C0.45,0 0.47,0.1 0.55,0.1 C0.63,0.1 0.65,0 0.65,0 H1 V1 H0 V0.55 C0,0.55 0.1,0.53 0.1,0.45 C0.1,0.37 0,0.35 0,0.35 V0 Z"></path></clipPath>
        </defs>
    </svg>

    <div id="instruction">
        <h2>국적 확인 퍼즐</h2>
        <p>조각을 맞춰 국기를 완성하세요.</p>
    </div>

    <div id="puzzle-container"></div>

    <div id="modal">
        <h1 id="result-text">국기 완성!</h1>
        <p id="result-sub">이 국가는 당신의 국적인가요?</p>
        <div style="display:flex; gap:10px;">
            <button onclick="confirmNationality(true)">내 국적입니다 (가입)</button>
            <button onclick="confirmNationality(false)" style="background:#ff5555">아닙니다 (제거)</button>
        </div>
    </div>

    <script>
        // 1. 데이터 및 설정
        // (테스트를 위해 국가 수를 줄였습니다. 실제 사용 시 원래 목록을 사용하세요)
        const countries = [
            { code: 'KR', name: '한국', color: '#003478' }, 
            { code: 'US', name: '미국', color: '#3C3B6E' },
            { code: 'JP', name: '일본', color: '#BC002D' },
            // ... 나머지 국가들
        ];

        const ROWS = 3;
        const COLS = 3;
        // 원래 격자 크기 (배경 이미지 계산용)
        const GRID_W = 60; 
        const GRID_H = 40;
        // 실제 조각 크기 (요철 포함 CSS 크기)
        const PIECE_W = 80; 
        const PIECE_H = 60;
        // 조각 내부의 실제 그림 시작 오프셋 (요철 때문에 그림이 밀리는 정도)
        const OFFSET_X = 10; 
        const OFFSET_Y = 10;

        const SNAP_TOLERANCE = 20;

        let activePiece = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let completedCountry = null;

        function init() {
            const container = document.getElementById('puzzle-container');
            countries.forEach(country => {
                createPuzzleForCountry(country, container);
            });
        }

        function createPuzzleForCountry(country, container) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = document.createElement('div');
                    piece.classList.add('puzzle-piece');
                    
                    // ★ 중요: 위치에 따른 클래스 추가 (SVG clip-path 연결용)
                    piece.classList.add(`pos-${r}-${c}`);
                    
                    piece.dataset.country = country.code;
                    piece.dataset.r = r;
                    piece.dataset.c = c;
                    
                    // 스타일 및 배경 이미지 설정
                    // piece.style.backgroundImage = `url('images/${country.code}.svg')`; // SVG 사용 시 주석 해제
                    piece.style.backgroundColor = country.color;
                    piece.innerText = country.code;

                    // ★ 배경 위치 계산 업데이트 ★
                    // 조각이 실제 격자보다 크고 요철이 있으므로, 배경 이미지를 약간 이동시켜야 중앙에 맞습니다.
                    // 원래 위치에서 OFFSET 만큼을 빼서 이미지를 왼쪽/위로 당깁니다.
                    const bgX = -(c * GRID_W) + OFFSET_X;
                    const bgY = -(r * GRID_H) + OFFSET_Y;
                    piece.style.backgroundPosition = `${bgX}px ${bgY}px`;

                    // 랜덤 배치
                    const x = Math.random() * (window.innerWidth - PIECE_W);
                    const y = Math.random() * (window.innerHeight - PIECE_H);
                    piece.style.left = `${x}px`;
                    piece.style.top = `${y}px`;

                    // 이벤트 리스너
                    piece.addEventListener('mousedown', onMouseDown);
                    piece.addEventListener('touchstart', onTouchStart, {passive: false});

                    container.appendChild(piece);
                }
            }
        }

        // --- 드래그 앤 드롭 (이전 코드와 동일) ---
        function onMouseDown(e) { startDrag(e.target, e.clientX, e.clientY); }
        function onTouchStart(e) { e.preventDefault(); startDrag(e.target, e.touches[0].clientX, e.touches[0].clientY); }

        function startDrag(element, clientX, clientY) {
            if(element.classList.contains('snapped')) return;
            activePiece = element;
            const rect = activePiece.getBoundingClientRect();
            dragOffsetX = clientX - rect.left;
            dragOffsetY = clientY - rect.top;
            activePiece.style.zIndex = 1000;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onTouchMove, {passive: false});
            document.addEventListener('touchend', onMouseUp);
        }

        function onMouseMove(e) { if (!activePiece) return; movePiece(e.clientX, e.clientY); }
        function onTouchMove(e) { if (!activePiece) return; e.preventDefault(); movePiece(e.touches[0].clientX, e.touches[0].clientY); }

        function movePiece(clientX, clientY) {
            const x = clientX - dragOffsetX;
            const y = clientY - dragOffsetY;
            activePiece.style.left = `${x}px`;
            activePiece.style.top = `${y}px`;
        }

        function onMouseUp() {
            if (!activePiece) return;
            checkSnap(activePiece);
            activePiece.style.zIndex = '';
            activePiece = null;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onMouseUp);
        }

        // --- 스냅 및 완성 체크 (로직 업데이트) ---
        function checkSnap(piece) {
            const currentR = parseInt(piece.dataset.r);
            const currentC = parseInt(piece.dataset.c);
            const countryCode = piece.dataset.country;
            const siblings = document.querySelectorAll(`.puzzle-piece[data-country="${countryCode}"]`);
            
            siblings.forEach(sibling => {
                if (sibling === piece) return;
                const targetR = parseInt(sibling.dataset.r);
                const targetC = parseInt(sibling.dataset.c);

                // ★ 거리 계산 업데이트 ★
                // 실제 조각 크기(PIECE_W/H)가 아닌 원래 격자 크기(GRID_W/H)를 기준으로 거리를 계산해야 합니다.
                const idealDistX = (targetC - currentC) * GRID_W;
                const idealDistY = (targetR - currentR) * GRID_H;

                const currentRect = piece.getBoundingClientRect();
                const siblingRect = sibling.getBoundingClientRect();
                const distDiffX = Math.abs((siblingRect.left - currentRect.left) - idealDistX);
                const distDiffY = Math.abs((siblingRect.top - currentRect.top) - idealDistY);

                if (distDiffX < SNAP_TOLERANCE && distDiffY < SNAP_TOLERANCE) {
                    piece.style.left = `${siblingRect.left - idealDistX}px`;
                    piece.style.top = `${siblingRect.top - idealDistY}px`;
                    checkCompletion(countryCode);
                }
            });
        }

        function checkCompletion(countryCode) {
            const pieces = Array.from(document.querySelectorAll(`.puzzle-piece[data-country="${countryCode}"]`));
            const basePiece = pieces[0];
            const baseRect = basePiece.getBoundingClientRect();
            const baseR = parseInt(basePiece.dataset.r);
            const baseC = parseInt(basePiece.dataset.c);
            let isComplete = true;

            for(let i=1; i<pieces.length; i++) {
                const p = pieces[i];
                const rect = p.getBoundingClientRect();
                const r = parseInt(p.dataset.r);
                const c = parseInt(p.dataset.c);
                // 완성 체크도 GRID 크기 기준
                const idealX = baseRect.left + (c - baseC) * GRID_W;
                const idealY = baseRect.top + (r - baseR) * GRID_H;
                if (Math.abs(rect.left - idealX) > 5 || Math.abs(rect.top - idealY) > 5) {
                    isComplete = false;
                    break;
                }
            }

            if (isComplete) {
                // 완성된 조각들을 맨 위로 올림
                pieces.forEach(p => p.style.zIndex = 1500);
                const countryName = countries.find(c => c.code === countryCode).name;
                showModal(countryName, countryCode);
            }
        }

        // --- 모달 처리 (이전과 동일) ---
        function showModal(name, code) {
            completedCountry = code;
            document.getElementById('result-text').innerText = `${name} 국기 완성!`;
            document.getElementById('modal').style.display = 'flex';
        }

        function confirmNationality(isMyCountry) {
            const modal = document.getElementById('modal');
            modal.style.display = 'none';
            const pieces = document.querySelectorAll(`.puzzle-piece[data-country="${completedCountry}"]`);

            if (isMyCountry) {
                alert(`환영합니다! ${completedCountry} 국적으로 진행합니다.`);
            } else {
                alert(`${completedCountry} 국기 퍼즐이 제거됩니다.`);
                pieces.forEach(p => p.remove());
            }
        }

        init();
    </script>
</body>
</html>
